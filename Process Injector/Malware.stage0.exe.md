# Basic Static Analysis
Using Floss, I've found those paths :
- C:\\Users\\Administrator\\source\\repos\\CRTInjectorConsole\\Release\\CRTInjectorConsole.pdb
- C:\\Users\\Public\\werflt.exe
- 
Possible malicious using of: CreateRemoteThread and WriteProcessMemory
The PE doesn't seem to be packed
The MITRE techniques also tend to confirm that the malware is a process injector:
![[Pasted image 20240316165021.png]]
# Basic Dynamic Analysis
We detonate the malware sample.
First thing we can see is that an executable is created in the path above:
![[Pasted image 20240316224515.png]]
![[Pasted image 20240316223810.png]]
The malware also creates a WerFault.exe process:
![[Pasted image 20240316230317.png]]
The werflt executable creates a Conhost.exe process:
![[Pasted image 20240316225113.png]]
It also creates some threads:
![[Pasted image 20240316225158.png]]
We also can see some weird communication on wireshark:
![[Pasted image 20240316225653.png]]
We can see here that WerFault.exe opens up a connection on local host on port 8443 as soon as we detonate the malware, the problem here is that WerFault is a legit Windows executable, why does it happen then?
![[Pasted image 20240316225902.png]]
We now try to see what WerFault.exe does:
![[Pasted image 20240316230631.png]]
The process is started by the malware and a thread is created, after 7 seconds, another thread is created, a lot of stuff happens, and here we can see:
![[Pasted image 20240316230759.png]]
WerFault opens up a TCP connection, then after some seconds, the process is shut. Notice that we have multiple threads in here:
![[Pasted image 20240316230939.png]]
# Advanced Static Analysis
![[Pasted image 20240317011337.png]]
The disassembly of the main function of werflt.exe executable shows that it calls: OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread, and finally CloseHandle Windows API calls.
Just by inspecting this, we find out the common pattern of process injection.
## What does the program do?
Basically, we give a process id to the program as an argument, it is then passed to OpenProcess that opens it with all permissions so that the malware has full control of it. Then, we pass the handle to VirtuallAllocEx to allocate memory for the data that will be injected. The injected data is in the lpBuffer variable, it is probably a shellcode, so we use WriteProcessMemory to write those bytes into the target process. We finally CreateRemoteThread that starts at the lpBuffer.
Using Process Hacker we can actually see the Shellcode bytes:
![[Pasted image 20240317014322.png]]